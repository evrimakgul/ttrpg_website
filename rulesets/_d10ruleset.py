# %%
# -*- coding: utf-8 -*-
"""d10ruleset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lCIzjYbkhAIdU18uDAqE-XM_OXwux1u5
"""

from typing import List, Dict, Any, Callable
import random

def roll_dice(number: int, sides: int) -> int:
    """Rolls dice and returns the total."""
    return sum(random.randint(1, sides) for _ in range(number))


class Actions:
    def __init__(self):
        self.action_points = 0
        self.actions_list = [
            {"name": "Attack", "cost": 5},
            {"name": "Defense", "cost": 2},
            {"name": "Cast a Spell", "cost": 5},
            {"name": "Move", "cost": "variable"}
        ]

    def perform_action(self, action_name: str, distance: int = None):
        action = next((a for a in self.actions_list if a["name"] == action_name), None)
        if action is None:
            print(f"Action {action_name} not found.")
            return

        cost = action["cost"]
        if action_name == "Move":
            if distance is None:
                print("Distance is required for the Move action.")
                return

            # Calculate maximum possible distance based on current AP
            max_distance = self.action_points * 2

            # Determine actual distance moved (limited by requested distance or max possible)
            actual_distance = min(distance, max_distance)

            # Calculate the cost for the actual distance moved
            cost = int(actual_distance / 2) # Cost is based on the distance actually moved

            if actual_distance == 0:
                 print(f"Not enough action points ({self.action_points}) to move at all.")
                 return

            # The main logic is now about *how far* you can move.
            print(f"Performing action: {action_name}, Attempted Distance: {distance}, Actual Distance Moved: {actual_distance}, Cost: {cost}, Remaining Action Points: {self.action_points - cost}")
            self.action_points -= cost
            return # Exit after handling move

        # This part handles non-Move actions
        if self.action_points >= cost:
            self.action_points -= cost
            print(f"Performing action: {action_name}, Cost: {cost}, Remaining Action Points: {self.action_points}")
        else:
            print(f"Not enough action points ({self.action_points}) to perform {action_name}.")

class Abilities:
    # Using a dictionary is much simpler for name-based lookups
    def __init__(self):
        self.abilities_dict: Dict[str, int] = {}

    def add_ability(self, name: str, value: int):
        if name in self.abilities_dict:
            print(f"Ability {name} already exists. Use update_ability instead.")
            return
        self.abilities_dict[name] = value
        print(f"Ability {name} added with value {value}.")


    def display(self):
        for name, value in self.abilities_dict.items():
            print(f"- {name}: {value}")

    def modify_ability(self, name: str, modifier: int):
        if name in self.abilities_dict:
            self.abilities_dict[name] += modifier
            print(f"{name} modified by {modifier}. New value: {self.abilities_dict[name]}")
        else:
            print(f"Ability {name} not found.")

    def get_ability_value(self, name: str) -> int | None: # Use Union or | for optional return
        return self.abilities_dict.get(name) # get() is safer, returns None if not found

    def get_physical_stats(self) -> Dict[str, int | None]:
        return {
            "Strength": self.get_ability_value("Strength"),
            "Dexterity": self.get_ability_value("Dexterity"),
            "Constitution": self.get_ability_value("Constitution")
        }

    def get_mental_stats(self) -> Dict[str, int | None]:
        return {
            "Intelligence": self.get_ability_value("Intelligence"),
            "Perception": self.get_ability_value("Perception"),
            "Wits": self.get_ability_value("Wits")
        }

    def get_social_stats(self) -> Dict[str, int | None]:
        return {
            "Appearance": self.get_ability_value("Appearance"),
            "Charisma": self.get_ability_value("Charisma"),
            "Composure": self.get_ability_value("Composure")
        }

    def update_ability(self, name: str, new_value: int):
        if name in self.abilities_dict:
            self.abilities_dict[name] = new_value
            print(f"{name} updated to {new_value}.")
        else:
            print(f"Ability {name} not found.")

class Skills:
    # Using a dictionary here too
    def __init__(self):
        self.skills_dict: Dict[str, int] = {}

    def add_skill(self, name: str, value: int):
        if name in self.skills_dict:
             print(f"Skill {name} already exists. Use update logic if needed.")
             return
        self.skills_dict[name] = value
        print(f"Skill {name} added with value {value}.")

    def display(self):
        for name, value in self.skills_dict.items():
            print(f"- {name}: {value}")

    def remove_skill(self, name:str):
        if name in self.skills_dict:
            del self.skills_dict[name] # Direct deletion from dict
            print(f"Skill {name} removed successfully")
        else:
            print(f"Skill {name} not found")

    def get_skill_value(self, name: str) -> int | None:
         return self.skills_dict.get(name)

class CharacterSheet:
    def __init__(self, name: str):
        self.name = name
        # Instantiate separate classes
        self.actions = Actions()
        self.abilities = Abilities()
        self.skills = Skills()
        self.initiative: int = 0 # Add initiative attribute
        self._has_passed_turn: bool = False # Track if player has passed this turn

        # Initialize all abilities directly into the dictionary
        initial_abilities = ["Strength", "Dexterity", "Constitution", "Intelligence",
                             "Perception", "Wits", "Appearance", "Charisma", "Composure"]
        for ability_name in initial_abilities:
            self.abilities.add_ability(ability_name, 1) # Use the add method

        # Calculate initial action points based on initial abilities
        self.calculate_action_points()

    def calculate_action_points(self):
        # Get values directly using the dictionary-based getter
        strength = self.abilities.get_ability_value("Strength") or 0 # Handle potential None
        dexterity = self.abilities.get_ability_value("Dexterity") or 0
        constitution = self.abilities.get_ability_value("Constitution") or 0
        self.actions.action_points = strength + dexterity + constitution
        print(f"{self.name}'s Action Points calculated: {self.actions.action_points}")

    # Add a method to roll initiative
    def roll_initiative(self, dice_sides: int = 10):
        """Rolls initiative (e.g., 1d10 + current AP) and sets the initiative score."""
        initiative_roll = roll_dice(1, dice_sides)
        # Initial initiative includes the roll and current AP
        self.initiative = initiative_roll + self.actions.action_points
        print(f"{self.name} rolled {initiative_roll} + {self.actions.action_points} AP. Initial Initiative: {self.initiative}")

    def reset_turn_state(self):
        """Resets state for the start of a new turn/round."""
        self._has_passed_turn = False
        # AP is typically reset at the start of a round, based on stats
        self.calculate_action_points() # Recalculate AP based on current stats

    def pass_turn(self):
        """Marks the character as having passed their turn."""
        self._has_passed_turn = True
        print(f"{self.name} passes their turn.")

    def has_passed(self) -> bool:
        """Checks if the character has passed their turn this round."""
        return self._has_passed_turn


class TurnManager:
    def __init__(self):
        self.participants: List[CharacterSheet] = []
        self.turn_queue: List[CharacterSheet] = []
        self.is_combat_active: bool = False
        self._initiative_dice_sides: int = 10 # Default dice for initiative

    def activate_combat(self, participants: List[CharacterSheet], initiative_dice_sides: int = 10):
        """Starts combat mode, rolls initiative, and sets up the turn queue."""
        if self.is_combat_active:
            print("Combat is already active.")
            return

        print("\n--- Combat Activated! ---")
        self.is_combat_active = True
        self.participants = participants
        self._initiative_dice_sides = initiative_dice_sides

        # Prepare for the first round
        self._start_new_round()

    def _start_new_round(self):
        """Sets up for a new round of combat."""
        print("\n--- Starting New Round ---")
        self.turn_queue = []

        # Reset state and roll initiative for all participants
        for participant in self.participants:
            participant.reset_turn_state() # Recalculates AP and resets pass state
            participant.roll_initiative(self._initiative_dice_sides)
            self.turn_queue.append(participant)

        # Sort the initial turn queue by initiative (highest first)
        self._sort_queue()

        print("\n--- Turn Order ---")
        self.display_turn_order()
        print("------------------")

        if self.turn_queue:
            print(f"It is {self.get_current_player().name}'s turn.")
        else:
            print("No participants in combat.")
            self.end_combat() # End combat if no participants

    def _sort_queue(self):
        """Sorts the turn queue by current initiative score (descending)."""
        self.turn_queue.sort(key=lambda char: char.initiative, reverse=True)

    def display_turn_order(self):
        """Prints the current order of players in the turn queue."""
        if not self.turn_queue:
            print("Turn queue is empty.")
            return
        for i, char in enumerate(self.turn_queue):
            status = " (Passed)" if char.has_passed() else ""
            print(f"{i+1}. {char.name} (Initiative: {char.initiative}, AP: {char.actions.action_points}){status}")

    def get_current_player(self) -> CharacterSheet | None:
        """Gets the player whose turn it is (first in queue who hasn't passed)."""
        if not self.is_combat_active or not self.turn_queue:
            return None
        # Find the first player in the sorted queue who hasn't passed
        for player in self.turn_queue:
            if not player.has_passed():
                return player
        return None # All players have passed

    def perform_action_for_current_player(self, action_name: str, distance: int = None):
        """Allows the current player to perform an action."""
        if not self.is_combat_active:
            print("Combat is not active.")
            return

        current_player = self.get_current_player()
        if not current_player:
            print("No current player or all players have passed. Check if turn should end.")
            return

        print(f"\n{current_player.name}'s action:")
        initial_ap = current_player.actions.action_points
        initial_initiative = current_player.initiative

        # Perform the action (this modifies AP)
        current_player.actions.perform_action(action_name, distance)

        # Calculate AP spent
        ap_spent = initial_ap - current_player.actions.action_points

        # If AP was spent, deduct from initiative and re-sort
        if ap_spent > 0:
            current_player.initiative -= ap_spent
            print(f"{current_player.name}'s Initiative decreased by {ap_spent} to {current_player.initiative}.")
            self._sort_queue() # Re-sort the queue based on new initiative

        # After action, check if all players have passed or if the current player now has 0 AP
        # Note: The rule is "when all players declare no more actions".
        # Having 0 AP doesn't *force* a pass, but often implies it.
        # We rely on the player explicitly calling pass_turn().
        self._check_end_of_turn()
        self.display_turn_order() # Show the updated order

        # After an action, the *next* player in the sorted queue who hasn't passed gets their turn
        # The get_current_player() method handles finding the next player automatically
        next_player = self.get_current_player()
        if next_player and next_player != current_player:
             print(f"\nIt is now {next_player.name}'s turn.")
        elif next_player == current_player:
             print(f"\nIt is still {current_player.name}'s turn (Initiative: {current_player.initiative}).")


    def player_pass_turn(self):
        """Allows the current player to pass their turn."""
        if not self.is_combat_active:
            print("Combat is not active.")
            return

        current_player = self.get_current_player()
        if not current_player:
            print("No current player to pass turn.")
            return

        current_player.pass_turn()
        self._check_end_of_turn()
        self.display_turn_order() # Show the updated order

        next_player = self.get_current_player()
        if next_player:
             print(f"\nIt is now {next_player.name}'s turn.")


    def _check_end_of_turn(self):
        """Checks if all players have passed their turn."""
        if not self.is_combat_active or not self.participants:
            return False

        all_passed = all(p.has_passed() for p in self.participants)

        if all_passed:
            self._end_turn()
            return True
        return False

    def _end_turn(self):
        """Executes end-of-turn logic (add remaining AP to initiative) and starts next round."""
        print("\n--- End of Turn ---")
        for participant in self.participants:
            remaining_ap = participant.actions.action_points
            participant.initiative += remaining_ap
            print(f"{participant.name} adds remaining {remaining_ap} AP to Initiative. New Initiative: {participant.initiative}")

        # Start the next round immediately after end-of-turn processing
        self._start_new_round()


    def end_combat(self):
        """Ends combat mode."""
        if not self.is_combat_active:
            print("Combat is not active.")
            return
        print("\n--- Combat Ended ---")
        self.is_combat_active = False
        self.participants = []
        self.turn_queue = []


# Example Usage:
if __name__ == "__main__":
    my_character = CharacterSheet("Brave Sir Robin")

    print("\nInitial Abilities:")
    my_character.abilities.display()

    print("\nCalculating AP:")
    my_character.calculate_action_points()

    print("\nAttempting Actions:")
    my_character.actions.perform_action("Attack")
    my_character.actions.perform_action("Move", distance=10) # Cost 5 (10/2)
    my_character.actions.perform_action("Defense")
    my_character.actions.perform_action("Move", distance=2) # Cost 1 (2/2)
    my_character.actions.perform_action("Cast a Spell") # Should fail now

    print("\nModifying Strength:")
    my_character.abilities.modify_ability("Strength", 3)

    print("\nRecalculating AP:")
    my_character.calculate_action_points()

    print("\nAttempting Actions Again:")
    my_character.actions.perform_action("Cast a Spell") # Should work now

    print("\nAdding Skills:")
    my_character.skills.add_skill("Stealth", 2)
    my_character.skills.add_skill("Speech", 3)
    my_character.skills.display()

    print("\nRemoving Skill:")
    my_character.skills.remove_skill("Stealth")
    my_character.skills.display()

    print("\nGetting single skill value:")
    stealth_val = my_character.skills.get_skill_value("Stealth")
    speech_val = my_character.skills.get_skill_value("Speech")
    print(f"Stealth value: {stealth_val}")
    print(f"Speech value: {speech_val}")




# %%

class RulesetManager:
    def __init__(self):
        self.rulesets: Dict[str, Any] = {}

    def add_ruleset(self, name: str, ruleset: Any):
        if name in self.rulesets:
            print(f"Ruleset '{name}' already exists.")
            return
        self.rulesets[name] = ruleset
        print(f"Ruleset '{name}' added.")

    def get_ruleset(self, name: str) -> Any | None:
        return self.rulesets.get(name)

    def list_rulesets(self) -> List[str]:
        return list(self.rulesets.keys())


class Argo:
    def __init__(self):
        self.actions = Actions()
        self.abilities = Abilities()
        self.skills = Skills()
        self.character_sheet = CharacterSheet("Default Character") # Example instantiation
        self.turn_manager = TurnManager()





# %%

# Example usage:
if __name__ == "__main__":
    # Create a RulesetManager
    ruleset_manager = RulesetManager()
    
    # Create an Argo ruleset instance
    argo_ruleset = Argo()
    
    # Add the Argo ruleset to the RulesetManager
    ruleset_manager.add_ruleset("Argo", argo_ruleset)
    
    # List available rulesets
    print("\nAvailable Rulesets:")
    rulesets = ruleset_manager.list_rulesets()
    for ruleset_name in rulesets:
        print(f"- {ruleset_name}")
    
    # Retrieve the Argo ruleset from the RulesetManager
    retrieved_argo = ruleset_manager.get_ruleset("Argo")
    if retrieved_argo:
        print("\nSuccessfully retrieved Argo ruleset")
        
        # Create a character using the retrieved Argo ruleset's components
        character_name = "Brave Sir Robin"
        print(f"\nCreating character '{character_name}' using Argo ruleset")
        
        # Use the character sheet from the Argo ruleset as a template
        # In a real implementation, you might clone this or create a new one
        my_character = CharacterSheet(character_name)
        
        print("\nInitial Abilities:")
        my_character.abilities.display()
        
        print("\nCalculating AP:")
        my_character.calculate_action_points()
        
        print("\nAttempting Actions:")
        my_character.actions.perform_action("Attack")
        my_character.actions.perform_action("Move", distance=10) # Cost 5 (10/2)
        my_character.actions.perform_action("Defense")
        
        print("\nModifying Strength:")
        my_character.abilities.modify_ability("Strength", 3)
        
        print("\nRecalculating AP:")
        my_character.calculate_action_points()
        
        print("\nAdding Skills:")
        my_character.skills.add_skill("Stealth", 2)
        my_character.skills.add_skill("Speech", 3)
        my_character.skills.display()
        
        # Example of using the TurnManager from the Argo ruleset
        print("\nDemonstrating combat with TurnManager:")
        combat_manager = retrieved_argo.turn_manager
        
        # Create another character for the combat demonstration
        enemy = CharacterSheet("Evil Knight")
        enemy.abilities.modify_ability("Strength", 2)
        enemy.calculate_action_points()
        
        # Activate combat with both characters
        combat_manager.activate_combat([my_character, enemy])
        
        # Perform an action with the current player
        combat_manager.perform_action_for_current_player("Attack")
        
        # End the combat
        combat_manager.end_combat()
        print("\nCombat demonstration completed")
